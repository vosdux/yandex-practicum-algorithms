/*
ID: 89206761 
-- ПРИНЦИП РАБОТЫ --
Я завел два указателя на начало и конец интервала. Изначально этот интервал на всю длину массива
Нахожу центральный элемент.
Если центральный элемент === k, то возвращаем ответ
Если левый край меньше центрального и k входит между ними, то продолжаем поиск в интервале от левого до центрального
Если k не входит в интревал, то продолжаем поиск в интервале от середины до правого края
Еcли же левый край оказался больше центрального элемента, тогда проверяем,
если k входит в правую половину, тогда продолжаем поиск в правой половине
в противном случае ещем в левой половине
Повторяем операцию до тех пор, пока левый и правый указатель не сравняются

-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
Весь массив состоит из некоторых отсортированных последовательностей попав в одну из таких
последовательностей мы можем найти нужный нам элемент бинарным поиском

-- ВРЕМЕННАЯ СЛОЖНОСТЬ --
Таким алгоритмом мы не будем проходиться по всем элементам массива даже в худшем случае,
поэтому сложность поиска будет O(logn)

-- ПРОСТРАНСТВЕННАЯ СЛОЖНОСТЬ --
В памяти мы храним только указатели left, right и mid
Поэтому нам необходимо O(1) памяти

*/

function brokenSearch(arr, k) {
  let left = 0;
  let right = arr.length - 1;

  while (left <= right) {
    const mid = Math.floor((left + right) / 2);

    if (arr[mid] === k) {
      return mid;
    } else if (arr[left] <= arr[mid]) {
      if (arr[left] <= k && k < arr[mid]) {
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    } else {
      if (arr[mid] < k && k <= arr[right]) {
        left = mid + 1;
      } else {
        right = mid - 1;
      }
    }
  }

  return -1;
}

function test() {
  const arr = [19, 21, 100, 101, 1, 4, 5, 7, 12];
  if (brokenSearch(arr, 5) !== 6) {
    console.error("WA");
  }
}
