const _readline = require("readline");

const _reader = _readline.createInterface({
  input: process.stdin,
});

let input = [];

// Установим callback на считывание строки - так мы получим
// все строки из ввода в массиве _inputLines.
_reader.on("line", (line) => {
  input.push(line);
});
// Когда ввод закончится, будет вызвана функция solve.
process.stdin.on("end", solve);

function solve() {
  const [peaksCount, connectionsCount] = input[0].split(" ");
  const error = "Oops! I did it again";

  const adjList = getAdjList(Number(peaksCount));

  if (connectionsCount === "0") {
    if (peaksCount === "1") {
      console.log(0);
      return;
    } else {
      console.log(error);
      return;
    }
  }

  function findMST() {
    let visited = new Set();
    let priorityQueue = new PriorityQueue();
    let weight = 0;
 
    visited.add(1);
    adjList[1].forEach(edge => {
      priorityQueue.enqueue(edge[0], edge[1]);
    });
 
    while (!priorityQueue.isEmpty()) {
      let minEdge = priorityQueue.dequeue();
 
      if (visited.has(minEdge.data)) {
        continue;
      }
 
      visited.add(minEdge.data);
      weight += minEdge.priority
 
      let adjacentEdges = adjList[minEdge.data];
      adjacentEdges.forEach(edge => {
        if (!visited.has(edge.vertex)) {
          priorityQueue.enqueue(edge[0], edge[1]);
        }
      });
    }

    if (visited.size !== Number(peaksCount)) {
      console.log('Oops! I did it again')
    } else {
      console.log(weight)
    }
 
  }

  findMST();
}

function getAdjList(peaksCount) {
  const map = {};
  for (let i = 1; i < Number(peaksCount) + 1; i++) {
    map[i] = [];
  }

  for (let i = 1; i < input.length; i++) {
    const [from, to, weight] = input[i].split(" ");
    const numberFrom = Number(from);
    const numberTo = Number(to);
    const numberWeight = Number(weight);

    map[numberFrom].push([numberTo, numberWeight]);
    map[numberTo].push([numberFrom, numberWeight]);
  }

  Object.keys(map).forEach((elem) => {
    map[elem] = map[elem].sort((a, b) => Number(a) - Number(b));
  });

  return map;
}

class PriorityQueue {
  constructor() {
    this.queue = [];
  }
 
  enqueue(data, priority) {
    this.queue.push({ data, priority });
    this.queue.sort((a, b) => a.priority - b.priority);
  }
 
  dequeue() {
    return this.queue.pop();
  }
 
  isEmpty() {
    return this.queue.length === 0;
  }
}